<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="多线程,并发,AbstractQueuedSynchronizer,AQS," />










<meta name="description" content="本文基于java version “1.8.0_77”  阅读本文章之前，你需要了解LockSupport中相关方法的介绍。阅读本篇文章，请对照源码阅读，否则可能云里雾里不知所云。 简介AbstractQueuedSynchronizer：译为：队列同步器（以下简称AQS），可以看到这是一个抽象类。有大名鼎鼎的并发大师Doug Lea设计： 并发包中很多Lock都是通过继承AQS实现的（Reen">
<meta name="keywords" content="多线程,并发,AbstractQueuedSynchronizer,AQS">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析">
<meta property="og:url" content="http://vinctor.cc/2017/12/05/java/concurrent/java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析/index.html">
<meta property="og:site_name" content="Vinctor&#39;s Home">
<meta property="og:description" content="本文基于java version “1.8.0_77”  阅读本文章之前，你需要了解LockSupport中相关方法的介绍。阅读本篇文章，请对照源码阅读，否则可能云里雾里不知所云。 简介AbstractQueuedSynchronizer：译为：队列同步器（以下简称AQS），可以看到这是一个抽象类。有大名鼎鼎的并发大师Doug Lea设计： 并发包中很多Lock都是通过继承AQS实现的（Reen">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-1f1beac67d19630e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-28c03151254aef8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-5a34f82bab7a4a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-376e68f0f37ee9f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-ddc292eb9cf9dd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-1eda1407f0e6d41f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-d424e94f17326da9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-aff10a5e985bb573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-2b6567a8dc61dd40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-48c676e2cb52cc0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-48c676e2cb52cc0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1583231-dd403f31ecbd15b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">
<meta property="og:updated_time" content="2017-12-14T07:21:12.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析">
<meta name="twitter:description" content="本文基于java version “1.8.0_77”  阅读本文章之前，你需要了解LockSupport中相关方法的介绍。阅读本篇文章，请对照源码阅读，否则可能云里雾里不知所云。 简介AbstractQueuedSynchronizer：译为：队列同步器（以下简称AQS），可以看到这是一个抽象类。有大名鼎鼎的并发大师Doug Lea设计： 并发包中很多Lock都是通过继承AQS实现的（Reen">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1583231-1f1beac67d19630e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://vinctor.cc/2017/12/05/java/concurrent/java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析/"/>





  <title>java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析 | Vinctor's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vinctor's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天道酬勤</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vinctor.cc/2017/12/05/java/concurrent/java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vinctor（猿，国家十级保护动物）">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vinctor's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java多线程之⑤——AbstractQueuedSynchronizer(AQS)源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T00:00:00+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java多线程/" itemprop="url" rel="index">
                    <span itemprop="name">java多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文基于java version “1.8.0_77”</p>
</blockquote>
<p>阅读本文章之前，你需要了解<a href="http://www.jianshu.com/p/8bdf56ee9e32" target="_blank" rel="noopener">LockSupport</a>中相关方法的介绍。<br>阅读本篇文章，请对照源码阅读，否则可能云里雾里不知所云。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AbstractQueuedSynchronizer：译为：队列同步器（以下简称AQS），可以看到这是一个抽象类。有大名鼎鼎的并发大师Doug Lea设计：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-1f1beac67d19630e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>并发包中很多Lock都是通过继承AQS实现的（ReentrantLock、<br>ReentrantReadWriteLock和CountDownLatch等），AQS中封装了实现锁的具体操作，其子类继承AQS后，可以轻松的调用AQS的相应方法来实现同步状态的管理同步状态，线程的排队，等待以及唤醒等操作。<br>子类可以重写的方法如下：</p>
<ul>
<li><code>protected boolean tryAcquire(int arg)</code>独占式的获取同步状态，使用CAS设置同步状态</li>
<li><code>protected boolean tryRelease(int arg)</code>独占式的释放同步状态</li>
<li><code>protected int tryAcquireShared(int arg)</code>共享式的获取同步状态，返回大于等于0的值，表示获取成功，否则失败</li>
<li><code>protected boolean tryReleaseShared(int arg)</code><br>共享式的释放同步状态</li>
<li><code>protected boolean isHeldExclusively()</code>判断当前是否被当前线程锁独占</li>
</ul>
<h1 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h1><p><img src="http://upload-images.jianshu.io/upload_images/1583231-28c03151254aef8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="image.png"></p>
<p>如上图，AQS中定义了一个volatile整数状态信息，我们可以通过<code>getState()</code>,<code>setState(int newState)</code>,<code>compareAndSetState(int expect,int update)）</code>等protected方法进行操作这一状态信息。例如：ReentrantLock中用它来表示所有线程呢个已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它来表示任务的状态（未开始，正在运行，已结束，已取消等）。</p>
<p>AQS是由一个同步队列（FIFO双向队列）来管理同步状态的，如果线程获取同步状态失败，AQS会将当前线程以及等待状态信息构造成一个节点（Node）加入到同步队列中，同时阻塞当前线程；当同步状态状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1583231-5a34f82bab7a4a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在跟着源码走流程之前，我们先了一下以下几个需要用到的概念：</p>
<h2 id="AQS-Node"><a href="#AQS-Node" class="headerlink" title="AQS.Node"></a>AQS.Node</h2><p>队列示意图如下:<br><img src="http://upload-images.jianshu.io/upload_images/1583231-376e68f0f37ee9f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>每个Node节点都是一个<code>自旋锁</code>：在阻塞时不断循环读取状态变量，当前驱节点释放同步对象使用权后，跳出循环，执行同步代码。我们在接下来的代码分析中，也能够看到通过死循环来达到自旋这一目的。</p>
<p>我们看一下Node节点类的几个关键属性（不必记住，下面用到的时候，再回来看即可）：</p>
<h4 id="MODE（两个）"><a href="#MODE（两个）" class="headerlink" title="MODE（两个）"></a>MODE（两个）</h4><p><img src="http://upload-images.jianshu.io/upload_images/1583231-ddc292eb9cf9dd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>两种Mode，用于创建Node时的构造函数使用。在<code>private Node addWaiter(Node mode)</code>这一方法调用的时候传入，用于想等待队列中添加节点。</p>
<h4 id="volatile-int-waitStatus"><a href="#volatile-int-waitStatus" class="headerlink" title="volatile int waitStatus"></a>volatile int waitStatus</h4><p>手机是<code>waitStatus</code>,用来表示当前节点的状态。其取值范围如下：</p>
<ul>
<li><p><code>static final int CANCELLED = 1</code>;表示节点的线程是已被取消的。当前节点由于超时或者被中断而被取消。一旦节点被取消后，那么它的状态值不在会被改变，且当前节点的线程不会再次被阻塞。</p>
</li>
<li><p><code>static final int SIGNAL= -1</code>;表示当前节点的后继节点的线程需要被唤醒。<code>当前节点的后继节点</code>已经 (或即将)被阻塞（通过LockSupport.park()） , 所以当 当前节点释放或则被取消时候，一定要unpark它的后继节点。为了避免竞争，获取方法一定要首先设置node为signal，然后再次重新调用获取方法，如果失败，则阻塞。</p>
</li>
<li><p><code>static final int CONDITION = -2;</code>表示线程正在等待某个条件。表示当前节点正在条件队列（AQS下的ConditionObject里也维护了个队列）中，在从conditionObject队列转移到同步队列前，它不会在同步队列（AQS下的队列）中被使用。当成功转移后，该节点的状态值将由CONDITION设置为0。</p>
</li>
<li><p><code>static final int PROPAGATE = -3;</code>表示下一个共享模式的节点应该无条件的传播下去。共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的。</p>
</li>
<li><p><code>0</code> 以上都不是。</p>
</li>
</ul>
<p>可以看到，非负数值（0和已经取消）意味着该节点不需要被唤醒。所以，大多数代码中不需要检查该状态值的确定值,只需要根据正负值来判断即可对于一个正常的Node，他的waitStatus初始化值时0。对于一个condition队列中的Node，他的初始化值时CONDITION。如果想要修改这个值，可以使用AQS提供CAS进行修改。（方法：<code>boolean 
 compareAndSetWaitStatus(Node node, int expect,int update)</code>）</p>
<h4 id="volatile-Node-prev"><a href="#volatile-Node-prev" class="headerlink" title="volatile Node prev"></a>volatile Node prev</h4><p>用于链接当前节点的前驱节点，当前节点依赖前驱节点来检测waitStatus，前驱节点是在当前节点入队时候被设置的。为了提高GC效率，在当前节点出队时候会把前驱节点设置为null。而且，在取消前驱节点的时候，则会while循环直到找到一个非取消（cancelled）的节点，由于头节点永远不会是取消状态，所以我们一定可以找到非取消状态的前置节点。</p>
<h4 id="volatile-Node-next"><a href="#volatile-Node-next" class="headerlink" title="volatile Node next;"></a>volatile Node next;</h4><p>用于链接当前节点的后继节点，在当前节点释放时候会唤醒后继节点。在一个当前节点入队的时候，会先设置当前节点的prev，而不会立即设置前置节点的next。而是用CAS替换了tail之后才设置前置节点的next。（方法Node addWaiter(Node mode)）</p>
<h4 id="Node-nextWaiter"><a href="#Node-nextWaiter" class="headerlink" title="Node nextWaiter"></a>Node nextWaiter</h4><p>用来串联条件队列，连接到下一个在条件上等待的结点或是特殊的值SHARED。因为条件队列只在独占模式下持有时访问，我们只需要一个简单的链表队列来持有在条件上等待的结点。再然后它们会被转移到同步队列（AQS队列）再次重新获取。由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。</p>
<h2 id="辅助方法分析（供查阅）"><a href="#辅助方法分析（供查阅）" class="headerlink" title="辅助方法分析（供查阅）"></a>辅助方法分析（供查阅）</h2><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><p>这个方法是信号控制（waitStatus）的核心。在获取同步状态失败，生成Node并加入队列中后，用于检查和更新结点的状态。返回true表示当前节点应该被阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * 前驱节点如果状态如果为SIGNAL。表明当前节点应被阻塞，等待唤醒（参见上文的SIGNAL状态）</span><br><span class="line">             * 则返回true，然后park挂起线程</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 前驱节点状态值大于0（只有一个取值1），表示前驱节点已经取消</span><br><span class="line">             * 此时应该丢弃前驱节点，而继续寻找前驱节点的前驱节点，（见下图）</span><br><span class="line">             * 这里使用while循环查找前驱节点，并将当前节点的prev属性设置为找到的新的节点。（下图步骤1）</span><br><span class="line">             * 并将新的前驱节点的后继节点设置为当前节点（下图步骤2）</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 排除以上SIGNAL（-1）和&gt;0（1）两种情况</span><br><span class="line">             * 现在是前驱节点的waitStatus为0或PROPAGATE（-3）的情况（不考虑CONDITION的情况）</span><br><span class="line">             * 这时候表明前驱节点需要重新设置waitStatus</span><br><span class="line">             * 这样在下一轮循环中，就可以判断前驱节点的SIGNAL而阻塞park当前节点，以便于等待前驱节点的unpark（比如：shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()）</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如图：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-1eda1407f0e6d41f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h4><p><img src="http://upload-images.jianshu.io/upload_images/1583231-d424e94f17326da9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<p>与上面的<code>shouldParkAfterFailedAcquire</code>中联合调用</p>
<blockquote>
<p>（shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()）</p>
</blockquote>
<p>通过<code>shouldParkAfterFailedAcquire</code>方法获取到可用的前驱节点，并设置前驱节点的WaitStatus值为SIGNAL，进而在此方法中将当前线程park（阻塞等待）。线程醒了之后，检查线程是否被重点，并将结果返回。</p>
<h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h4><p>上面讲到，每一个NODE节点都是一个自旋锁，都在不断进行死循环自旋，当自旋过程中发生异常而无法获得锁，就需要取消节点。<br>需要做的是：</p>
<ul>
<li>清空node节点中的引用</li>
<li>node出队：剔除当前节点，打断next和prev引用。分为三种情况：1. node是tail    2. node既不是tail，也不是head的后继节点  3.  node是head的后继节点<br>源码分析如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">       // 如果node为空，忽略，直接返回</span><br><span class="line">       if (node == null)</span><br><span class="line">           return;</span><br><span class="line">       </span><br><span class="line">       //将thread引用置空</span><br><span class="line">       node.thread = null;</span><br><span class="line"></span><br><span class="line">       // 跳过取消的（cancelled）的前置节点，找到一个有效的前驱节点，如上面分析过的shouldParkAfterFailedAcquire</span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       while (pred.waitStatus &gt; 0)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       // 拿到前驱节点的后继节点</span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       // 将节点的状态值设为已取消，这样，其他节点就可以跳过本节点，而不受其他线程的干扰</span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">       // 情况1：如果当前节点是尾节点，CAS替换tail字段的引用为为前驱节点</span><br><span class="line">       // 成功之后，CAS将前驱节点的后继节点置空</span><br><span class="line">       if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">           compareAndSetNext(pred, predNext, null);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // 情况2：如果当前节点不是tail，而前驱节点又不是head</span><br><span class="line">           // 则尝试CAS将前驱节点的waitStatus标记为SIGNAL（表示前驱节点的后继节点需要唤醒）</span><br><span class="line">           // 设置成功之后，CAS将前驱节点的后继节点设置为当前节点的后继节点（将当前节点剔除）</span><br><span class="line">           int ws;</span><br><span class="line">           if (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != null) &#123;</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                   compareAndSetNext(pred, predNext, next);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">           // 情况3：如果node是head的后继节点，则直接唤醒node的后继节点</span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           node.next = node; // help GC</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如上：<br>情况1：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-aff10a5e985bb573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<ul>
<li>1：compareAndSetTail(node, pred) 替换tail的引用</li>
<li>2：compareAndSetNext(pred, predNext, null); 将pred的next置空</li>
</ul>
<hr>
<p>情况2：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-2b6567a8dc61dd40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<h2 id="compareAndSetNext-pred-predNext-next-将前驱节点的next指向后继节点。后继节点的prev将在前面讲过的shouldParkAfterFailedAcquire进行添加。"><a href="#compareAndSetNext-pred-predNext-next-将前驱节点的next指向后继节点。后继节点的prev将在前面讲过的shouldParkAfterFailedAcquire进行添加。" class="headerlink" title="* compareAndSetNext(pred, predNext, next); 将前驱节点的next指向后继节点。后继节点的prev将在前面讲过的shouldParkAfterFailedAcquire进行添加。"></a>* compareAndSetNext(pred, predNext, next); 将前驱节点的next指向后继节点。后继节点的prev将在前面讲过的shouldParkAfterFailedAcquire进行添加。</h2><p>情况3</p>
<h2 id="下面将分析unparkSuccessor方法"><a href="#下面将分析unparkSuccessor方法" class="headerlink" title="下面将分析unparkSuccessor方法"></a>下面将分析unparkSuccessor方法</h2><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h4><p>用于唤醒当前节点的后继节点。<br>`<br>private void unparkSuccessor(Node node) {<br>       // 将当前节点的状态重置<br>        int ws = node.waitStatus;<br>        if (ws &lt; 0)<br>            compareAndSetWaitStatus(node, ws, 0);</p>
<pre><code>    // 拿到后继节点 ，如果后继机节点是空或标记为取消（cancelled）
    // 开是循环获取后继的可用节点
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    // LockSupport唤醒下一个节点
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><p><code>上文中寻找下一个可用节点的时候，可以看到不是head-&gt;tail寻找，而是tail-&gt;head倒序寻找，这是因为：通过上面代码可以看到，只有在当前节点node的后继节点为nul的时候，才会执行循环寻找后面的可用后继节点。注意此处：</code>后继节点已经为null了`，故只能从尾部向前遍历，找到第一个可用节点。</p>
<p>差不多就这些了，下面我们进入正题，探讨一下获取同步化状态的流程。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h3 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h3><p>上源码：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-48c676e2cb52cc0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<p>首先tryAcquire(arg)，tryAcquire是由子类实现，通过操作state进行判定当前是否允许当前线程获取执行权力，用来控制当前是否允许获取同步状态。true表示获取同步状态，不必加入同步队列中。如果返回了false，没有获取同步状态，则需要加入到同步队列中。继续往下执行：</p>
<h4 id="addWaiter-Node-mode"><a href="#addWaiter-Node-mode" class="headerlink" title="addWaiter(Node mode)"></a>addWaiter(Node mode)</h4><p>首先将节点添加到等待队列中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        // 构造一个Node，nextWaiter为null</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // 获取到tail节点（也就是接下来，当前节点的前驱节点）</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            // CAS尝试替换tail引用，如果成功，则返回</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 上述不成功，存在多线程竞争，则自旋</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="enq-final-Node-node"><a href="#enq-final-Node-node" class="headerlink" title="enq(final Node node)"></a>enq(final Node node)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 如果队列为空，先CAS设置一下head空节点，完事之后进行下一次循环</span><br><span class="line">            if (t == null) &#123; </span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 设置当前节点的prev，然后CAS设置设置tail，和前驱节点的next</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>添加队列成功之后，我们继续往下看，还是那张图<br><img src="http://upload-images.jianshu.io/upload_images/1583231-48c676e2cb52cc0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<h4 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h4><p>acquireQueued主要是处理正在排队等待的线程。自旋、阻塞重试获取。如果获取成功则替换当前节点为链表头，然后返回。在获取过程中，忽略了中断，但将是否中断的返回了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            // 死循环自旋，不断尝试获取同步状态</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //获取当前节点的前驱节点</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // 只有前驱节点是head，也就是说排队排到当前借钱，才有可能获取同步状态</span><br><span class="line">                // 如果允许获取同步状态，则将当前节点设置为head，设置其他标记，并返回，终止自旋</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 在上面同步获取失败后，有可能不是头节点的后继节点，这时没有资格获取同步状态，就需要休眠</span><br><span class="line">                // 下面代码上面讲过，进一步检查和更新节点状态，判断当前节点是否需要park，减少占用CPU，等待前驱节点释放同步状态将它唤醒</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 如果失败，取消获取同步状态，移除节点，上文已讲</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h4><p>获取锁过程中，忽略了中断，在这里处理中断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>获取分析完了，我们看一下，同步代码执行完毕，同步状态是如何释放的。</p>
<h3 id="独占式释放同步状态"><a href="#独占式释放同步状态" class="headerlink" title="独占式释放同步状态"></a>独占式释放同步状态</h3><p><code>public final boolean release(int arg) {
        //首先调用子类重写方法tryRelease，返回true标识标识允许释放同步状态
        if (tryRelease(arg)) {
            //如果允许释放，则当前head即为要释放的node，只需要唤醒后继node即可， unparkSuccessor上文讲过
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }</code><br>到此，我们走完了独占式锁的获取与释放。简要概述一下步骤：</p>
<ul>
<li>尝试获取锁，如果不能获取，添加进队列</li>
<li>队列中该node进行自旋排队，尝试获取同步状态</li>
<li>如果当前节点不是head的下个节点，休眠，等待唤醒</li>
<li>唤醒后，检查自身是否已被interrupted，继续尝试获取锁</li>
<li>获取后，执行同步代码，</li>
<li>执行完毕后，release锁，唤醒下个节点</li>
</ul>
<h3 id="共享式获取同步状态"><a href="#共享式获取同步状态" class="headerlink" title="共享式获取同步状态"></a>共享式获取同步状态</h3><p>上源码：<br><img src="http://upload-images.jianshu.io/upload_images/1583231-dd403f31ecbd15b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br>首先还是调用子类实现的tryAcquireShared，查看是否允许获取同步状态。如果首次获取结果大于等于0.则完成获取 。如果小于0，则表示不允许获取同步状态，进入队列。</p>
<h4 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h4><p>死循环自旋尝试获取锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">       // 构造Node，添加到队列中，模式为Node.SHARED，查看Node构造函数</span><br><span class="line">       // 可以看到，当前Node的nextWaiter（不是next，详看上文）为一个空node对象</span><br><span class="line">       final Node node = addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               // 拿到前驱node</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               // 前驱node是head才有可能获取锁</span><br><span class="line">               if (p == head) &#123;</span><br><span class="line">                   int r = tryAcquireShared(arg);</span><br><span class="line">                   if (r &gt;= 0) &#123;   // tryAcquireShared大于等于0，允许获取锁</span><br><span class="line">                      // 获取成功，需要将当前节点设置为AQS队列中的第一个节点</span><br><span class="line">                      // 这是AQS的规则，队列的头节点表示正在获取锁的节点</span><br><span class="line">                      // 下面讲解</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = null; // help GC</span><br><span class="line">                       // 同独占式</span><br><span class="line">                       if (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               // 不解释，见上文</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 不解释，见上文</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h4><p>这是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">        // 取到head做缓存</span><br><span class="line">        Node h = head; </span><br><span class="line">        //将当前节点设置为head</span><br><span class="line">        setHead(node);</span><br><span class="line">        // propagate是tryAcquireShared返回的值 ，可以理解为Semaphore，是否还允许其他并发</span><br><span class="line">        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">            (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            // 并检查当前节点的后继节点为空或者后继节点的nextWaiter是否为SHARED，表明后继节点需要共享传递</span><br><span class="line">            if (s == null || s.isShared())</span><br><span class="line">                doReleaseShared();  // 进行share传递， doReleaseShared</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里与独占式的做了相似的事情，都进行了设置head之后，区别是共享式获取同步状态又进行了share传递，传递给下一个nextWaiter属性同样为SHAREED的节点，我们看一下doReleaseShared方法</p>
<h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h4><p>`<br>private void doReleaseShared() {<br> /*</p>
<pre><code>     * 即使在并发，多个线程在获取、释放的情况下，确保释放的传播性,
     * 如果当前节点标记为SIGNAL（表示后继节点需要唤醒，按理说应该在当前节点释放的时候唤醒，但是此处是共享模式，故立即唤醒），则通常尝试头节点的unparkSuccessor 动作。
     * 但是如果他不符合唤醒的条件，为了确保能正确release，那么则把head的waitState设置为为PROPAGATE
     * 此外，在执行该代码时，为了以防万一有新
     * 节点的加入，或者我们CAS修改失败，所以我们的更新需要在循环中，不断尝试。
     */
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // 失败了就继续loop  
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // 失败了就继续loop  
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre><p>`</p>
<p>这里最重要的是要多线程环境中理解doReleaseShared，一个线程A执行doReleaseShared，然后unparkSuccessor，线程B唤醒执行，这时候被唤醒的线程B运行，重新请求获取同步状态，修改head节点，唤醒线程C，然后依次唤醒D、E、F……每个节点在自己唤醒的同时，也唤醒了后面的节点，设置为head，这样就达到了共享模式。</p>
<p>注意h == head，我们看到上面有注释说<code>Additionally, we must loop in case a new node is added while we are doing this.</code>为了避免在执行到这里的时候。如果有两个新的节点添加到队列中来，一个节点A唤醒B之后，B恰好setHead了，此时head是B节点。此时A之前获得的head并不是新的head了，故需要继续循环，以尽可能保证成功性。</p>
<blockquote>
<p>可以看到 独占式与共享式的差别就是共享的传递：<br>独占模式唤醒头节点，头节点释放之后，后继节点唤醒<br>共享模式唤醒全部节点。</p>
</blockquote>
<h3 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h3><p>源码不贴了，调用的是上述的doReleaseShared()</p>
<h3 id="响应中断获取锁"><a href="#响应中断获取锁" class="headerlink" title="响应中断获取锁"></a>响应中断获取锁</h3><p>acquireInterruptibly和acquire差不多，acquireSharedInterruptibly和acquireShared差不多，区别就是抛出了InterruptedException。</p>
<h1 id="———————–完毕————————"><a href="#———————–完毕————————" class="headerlink" title="———————–完毕————————-"></a>———————–完毕————————-</h1><p>下一篇继续撸Reentrantlock<br>本人能力有限，分析的不够的地方，还望多多指正。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/donate/wechat.jpg" alt="Vinctor（猿，国家十级保护动物） 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/donate/alipay.jpg" alt="Vinctor（猿，国家十级保护动物） 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
            <a href="/tags/AbstractQueuedSynchronizer/" rel="tag"># AbstractQueuedSynchronizer</a>
          
            <a href="/tags/AQS/" rel="tag"># AQS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/04/java/concurrent/java多线程之④——LockSupport/" rel="next" title="java多线程之④——LockSupport">
                <i class="fa fa-chevron-left"></i> java多线程之④——LockSupport
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/06/java/concurrent/java多线程之⑥——重入锁ReentrantLock/" rel="prev" title="java多线程之⑥——重入锁ReentrantLock">
                java多线程之⑥——重入锁ReentrantLock <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2151738" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Vinctor（猿，国家十级保护动物）" />
            
              <p class="site-author-name" itemprop="name">Vinctor（猿，国家十级保护动物）</p>
              <p class="site-description motion-element" itemprop="description">Android Java 日常随笔</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/vinctor" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xcht1209@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x7B80;&#x4ECB;" class="headerlink" title="&#x7B80;&#x4ECB;"></a>&#x7B80;&#x4ECB;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构成"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x6784;&#x6210;" class="headerlink" title="&#x6784;&#x6210;"></a>&#x6784;&#x6210;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#准备工作"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x51C6;&#x5907;&#x5DE5;&#x4F5C;" class="headerlink" title="&#x51C6;&#x5907;&#x5DE5;&#x4F5C;"></a>&#x51C6;&#x5907;&#x5DE5;&#x4F5C;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-Node"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#AQS-Node" class="headerlink" title="AQS.Node"></a>AQS.Node</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MODE（两个）"><span class="nav-number">3.1.0.1.</span> <span class="nav-text"><a href="#MODE&#xFF08;&#x4E24;&#x4E2A;&#xFF09;" class="headerlink" title="MODE&#xFF08;&#x4E24;&#x4E2A;&#xFF09;"></a>MODE&#xFF08;&#x4E24;&#x4E2A;&#xFF09;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-int-waitStatus"><span class="nav-number">3.1.0.2.</span> <span class="nav-text"><a href="#volatile-int-waitStatus" class="headerlink" title="volatile int waitStatus"></a>volatile int waitStatus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-Node-prev"><span class="nav-number">3.1.0.3.</span> <span class="nav-text"><a href="#volatile-Node-prev" class="headerlink" title="volatile Node prev"></a>volatile Node prev</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-Node-next"><span class="nav-number">3.1.0.4.</span> <span class="nav-text"><a href="#volatile-Node-next" class="headerlink" title="volatile Node next;"></a>volatile Node next;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-nextWaiter"><span class="nav-number">3.1.0.5.</span> <span class="nav-text"><a href="#Node-nextWaiter" class="headerlink" title="Node nextWaiter"></a>Node nextWaiter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#辅助方法分析（供查阅）"><span class="nav-number">3.2.</span> <span class="nav-text"><a href="#&#x8F85;&#x52A9;&#x65B9;&#x6CD5;&#x5206;&#x6790;&#xFF08;&#x4F9B;&#x67E5;&#x9605;&#xFF09;" class="headerlink" title="&#x8F85;&#x52A9;&#x65B9;&#x6CD5;&#x5206;&#x6790;&#xFF08;&#x4F9B;&#x67E5;&#x9605;&#xFF09;"></a>&#x8F85;&#x52A9;&#x65B9;&#x6CD5;&#x5206;&#x6790;&#xFF08;&#x4F9B;&#x67E5;&#x9605;&#xFF09;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shouldParkAfterFailedAcquire"><span class="nav-number">3.2.0.1.</span> <span class="nav-text"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parkAndCheckInterrupt"><span class="nav-number">3.2.0.2.</span> <span class="nav-text"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cancelAcquire"><span class="nav-number">3.2.0.3.</span> <span class="nav-text"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compareAndSetNext-pred-predNext-next-将前驱节点的next指向后继节点。后继节点的prev将在前面讲过的shouldParkAfterFailedAcquire进行添加。"><span class="nav-number">3.3.</span> <span class="nav-text"><a href="#compareAndSetNext-pred-predNext-next-&#x5C06;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x6307;&#x5411;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x3002;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x7684;prev&#x5C06;&#x5728;&#x524D;&#x9762;&#x8BB2;&#x8FC7;&#x7684;shouldParkAfterFailedAcquire&#x8FDB;&#x884C;&#x6DFB;&#x52A0;&#x3002;" class="headerlink" title="* compareAndSetNext(pred, predNext, next); &#x5C06;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x6307;&#x5411;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x3002;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x7684;prev&#x5C06;&#x5728;&#x524D;&#x9762;&#x8BB2;&#x8FC7;&#x7684;shouldParkAfterFailedAcquire&#x8FDB;&#x884C;&#x6DFB;&#x52A0;&#x3002;"></a>* compareAndSetNext(pred, predNext, next); &#x5C06;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x6307;&#x5411;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x3002;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x7684;prev&#x5C06;&#x5728;&#x524D;&#x9762;&#x8BB2;&#x8FC7;&#x7684;shouldParkAfterFailedAcquire&#x8FDB;&#x884C;&#x6DFB;&#x52A0;&#x3002;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下面将分析unparkSuccessor方法"><span class="nav-number">3.4.</span> <span class="nav-text"><a href="#&#x4E0B;&#x9762;&#x5C06;&#x5206;&#x6790;unparkSuccessor&#x65B9;&#x6CD5;" class="headerlink" title="&#x4E0B;&#x9762;&#x5C06;&#x5206;&#x6790;unparkSuccessor&#x65B9;&#x6CD5;"></a>&#x4E0B;&#x9762;&#x5C06;&#x5206;&#x6790;unparkSuccessor&#x65B9;&#x6CD5;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unparkSuccessor"><span class="nav-number">3.4.0.1.</span> <span class="nav-text"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码分析"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x6E90;&#x7801;&#x5206;&#x6790;" class="headerlink" title="&#x6E90;&#x7801;&#x5206;&#x6790;"></a>&#x6E90;&#x7801;&#x5206;&#x6790;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式获取同步状态"><span class="nav-number">4.0.1.</span> <span class="nav-text"><a href="#&#x72EC;&#x5360;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;" class="headerlink" title="&#x72EC;&#x5360;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;"></a>&#x72EC;&#x5360;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#addWaiter-Node-mode"><span class="nav-number">4.0.1.1.</span> <span class="nav-text"><a href="#addWaiter-Node-mode" class="headerlink" title="addWaiter(Node mode)"></a>addWaiter(Node mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enq-final-Node-node"><span class="nav-number">4.0.1.2.</span> <span class="nav-text"><a href="#enq-final-Node-node" class="headerlink" title="enq(final Node node)"></a>enq(final Node node)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireQueued-final-Node-node-int-arg"><span class="nav-number">4.0.1.3.</span> <span class="nav-text"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#selfInterrupt"><span class="nav-number">4.0.1.4.</span> <span class="nav-text"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占式释放同步状态"><span class="nav-number">4.0.2.</span> <span class="nav-text"><a href="#&#x72EC;&#x5360;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;" class="headerlink" title="&#x72EC;&#x5360;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;"></a>&#x72EC;&#x5360;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享式获取同步状态"><span class="nav-number">4.0.3.</span> <span class="nav-text"><a href="#&#x5171;&#x4EAB;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;" class="headerlink" title="&#x5171;&#x4EAB;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;"></a>&#x5171;&#x4EAB;&#x5F0F;&#x83B7;&#x53D6;&#x540C;&#x6B65;&#x72B6;&#x6001;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#doAcquireShared-int-arg"><span class="nav-number">4.0.3.1.</span> <span class="nav-text"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setHeadAndPropagate"><span class="nav-number">4.0.3.2.</span> <span class="nav-text"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doReleaseShared"><span class="nav-number">4.0.3.3.</span> <span class="nav-text"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享式释放同步状态"><span class="nav-number">4.0.4.</span> <span class="nav-text"><a href="#&#x5171;&#x4EAB;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;" class="headerlink" title="&#x5171;&#x4EAB;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;"></a>&#x5171;&#x4EAB;&#x5F0F;&#x91CA;&#x653E;&#x540C;&#x6B65;&#x72B6;&#x6001;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应中断获取锁"><span class="nav-number">4.0.5.</span> <span class="nav-text"><a href="#&#x54CD;&#x5E94;&#x4E2D;&#x65AD;&#x83B7;&#x53D6;&#x9501;" class="headerlink" title="&#x54CD;&#x5E94;&#x4E2D;&#x65AD;&#x83B7;&#x53D6;&#x9501;"></a>&#x54CD;&#x5E94;&#x4E2D;&#x65AD;&#x83B7;&#x53D6;&#x9501;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#———————–完毕————————"><span class="nav-number">5.</span> <span class="nav-text"><a href="#&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2013;&#x5B8C;&#x6BD5;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;" class="headerlink" title="&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2013;&#x5B8C;&#x6BD5;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;-"></a>&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2013;&#x5B8C;&#x6BD5;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;-</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vinctor（猿，国家十级保护动物）</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
